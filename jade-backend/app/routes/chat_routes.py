"""
API routes for handling document uploads and rulebook queries.

This module defines FastAPI endpoints that connect HTTP requests
to controller logic for uploading files and querying indexed documents.
"""

from fastapi import APIRouter, UploadFile, File, HTTPException, Form
from controllers import chat_controller
from models.api_models import QueryRequest, QueryResponse, UploadResponse
from logger import logger

router = APIRouter()


@router.post("/chat/upload/", response_model=UploadResponse)
async def upload_document(
    file: UploadFile = File(...),
    rag_type: str = Form(..., regex="^(HRAG|TradRAG)$")
):
    """
    Upload a document to the server and (re)build the selected RAG index.

    Args:
        file (UploadFile): The document file to be uploaded.
        rag_type (str): The type of RAG index to build ("HRAG" or "TradRAG").

    Returns:
        UploadFileResponse: Upload metadata including filename and message.

    Raises:
        HTTPException: If an error occurs during file handling or saving.
    """
    logger.info(f"Received upload request for file: {file.filename} with RAG type: {rag_type}")
    try:
        response = await chat_controller.upload_document(file, rag_type)
        logger.info(f"File {file.filename} uploaded and {rag_type} index built successfully.")
        return response
    except HTTPException as e:
        logger.error(f"HTTPException during file upload: {e.detail}", exc_info=True)
        raise e
    except Exception as e:
        logger.error(
            f"An unexpected error occurred during file upload: {e}", exc_info=True
        )
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")


@router.post("/queryHRAG", response_model=QueryResponse)
async def query_HRAG(request: QueryRequest):
    """
    Query document using the Hierarchical RAG (HRAG) system with a user-provided question.

    Forwards the query to the controller which interacts with
    the LLM-powered query engine.

    Args:
        request (QueryRequest): Contains the user's query text.

    Returns:
        QueryResponse: The answer generated by the query engine.

    Raises:
        HTTPException: If the query engine fails or is not initialized.
    """
    logger.info(f"Received query request: '{request.query}'")

    try:
        response = await chat_controller.query_hrag(request.query)
        logger.info("Query successfully processed.")
        return response
    except HTTPException as e:
        logger.error(f"HTTPException during rulebook query: {e.detail}", exc_info=True)
        raise e
    except Exception as e:
        logger.error(
            f"An unexpected error occurred during rulebook query: {e}", exc_info=True
        )
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")


@router.post("/queryRAG", response_model=QueryResponse)
async def query_trad_RAG(request: QueryRequest):
    """
    Query the traditional RAG system with a user-provided question.

    Forwards the query to the controller which interacts with
    the LLM-powered query engine.

    Args:
        request (QueryRequest): Contains the user's query text.

    Returns:
        QueryResponse: The answer generated by the query engine.

    Raises:
        HTTPException: If the query engine fails or is not initialized.
    """
    logger.info(f"Received traditional RAG query request: '{request.query}'")
    
    try:
        response = await chat_controller.query_trad_RAG(request.query)
        logger.info("Traditional RAG query successfully processed.")
        return response
    except HTTPException as e:
        logger.error(f"HTTPException during traditional RAG query: {e.detail}", exc_info=True)
        raise e
    except Exception as e:
        logger.error(
            f"An unexpected error occurred during traditional RAG query: {e}", exc_info=True
        )
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")